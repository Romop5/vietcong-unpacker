#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <clocale>

#include <iostream>

#include <map>
#include <set>

class Decoder
{
private:
	unsigned int	counter;
	//std::map<std::string, uint32_t>	dict;
	
	std::map<uint32_t, std::string>	dict;

	std::set<std::string> tokens;
	unsigned int	sizeOfCode;
	unsigned int	position;
public:
	Decoder::Decoder()
	{
		this->counter = 257;
		this->dict.clear();
		this->tokens.clear();
		this->sizeOfCode = 9;
		this->position = 0;
	}
	void	addToken(std::string tok)
	{
		if (tok.size() > 1)
		{

			//if (this->dict.count(tok) == 0)
			if(this->tokens.count(tok) == 0)
			{
				uint32_t id = counter++;
				this->dict[id] = tok;
				//this->dict[tok] = counter++;
				printf("Adding tok: '%s' (%u) with ID: %x\n", tok.c_str(), tok.size(), id);
			}
			else {
				//printf("Already in dict: %s\n",tok.c_str());
			}
		}
		// if dict is bigger than size of a code
		if (counter + 2 > (1 << this->sizeOfCode))
		{
			this->sizeOfCode++;
			printf("Current size: %x (dict len: %x)\n",this->sizeOfCode,this->counter);
		}
	}
	bool isTokenInDict(std::string token)
	{
		return (this->tokens.count(token) > 0);
		/*try {
			return (this->dict[token] > 0);
		}
		catch (int error)
		{
			return false;
		}*/
	}

	bool getTokenForID(unsigned id,std::string* token)
	{
		if (id < 256)
		{
			token += (char)id;
			return true;
		}

		try
		{
			*token = this->dict[id];
			return true;
		}
		catch (int err)
		{
			return false;
		}
		
		/*for (auto m : this->dict)
		{
			if (m.second == id)
			{
				*token = m.first;
				return true;
			}
		}*/

		return false;
	}

	std::string getToken(unsigned id)
	{
		if (id < 256)
		{
			std::string s;
			s += (char)id;
			return s;
		} else {
			try{
				if (this->dict[id][0] != NULL)
				{
					std::string str = this->dict[id];
					printf("For %X returning %s\n", id, str.c_str());
					return str;
				}
				throw - 1;

			}
			catch (int err)
			{
				printf("ID %x is not in da dict\n", id);
				throw err;
			}
		}
		return "BAD FUCKING STRING";

		/*for (auto m : this->dict)
		{
			if (m.second == id)
			{
				return m.first;
			}
		}*/

	}

	/*unsigned short	getValue(unsigned char data[], unsigned position)
	{
		unsigned bits = position * 9;

		unsigned at = bits / 8;
		return ((*(unsigned short*) (data+at) >> (bits % 8))) & (~(~0 << 9));
	}*/

	uint32_t	getValue(unsigned char data[])
	{
		//unsigned bits = position * 9;

		unsigned bytePos = this->position / 16;

		uint16_t* dt = (uint16_t*)data;

		uint16_t a = dt[bytePos];
		uint16_t b = dt[bytePos + 1];

		uint16_t aShift = this->position % 16;
		uint16_t bShift = 16 - aShift;

		uint32_t tok = ((a >> aShift) | b << bShift) & ((1 << this->sizeOfCode) - 1);
		//printf("getVal(%x) = %X - %u - %u (%d)\n", tok, *(uint32_t*)(data + bytePos), aShift, bShift, this->sizeOfCode);
		position += this->sizeOfCode;

		//printf("getVal %4x\n",tok);
		return tok;






	/*	unsigned char a = data[bytePos];
		unsigned char b = data[bytePos+1];

		unsigned short aShift = this->position % 8;
		unsigned short bShift = 8- aShift;

		unsigned short tok = ((a >> aShift) | b << bShift) & ((1 << this->sizeOfCode)-1);
		printf("getVal(%x) = %X - %u - %u (%d)\n",tok,*(uint32_t*) (data+bytePos),aShift,bShift,this->sizeOfCode);
		position += this->sizeOfCode;

		//printf("getVal %4x\n",tok);
		return tok;
		*/
		//unsigned at = bits / 8;
		//return ((*(unsigned short*)(data + at) >> (bits % 8))) & (~(~0 << 9));
	}

	/*void printHex(std::string input)
	{
		for (auto chr : input)
		{
			if (isspace(chr))
			{
				putchar(chr);
			} else if (isprint(chr))
				putchar(chr);
			else {
				printf("0x%2X",chr);
			}
		}
	}*/

	std::string toHex(std::string input)
	{
		return input;
		std::string output = "";
		for (unsigned i = 0; i < input.size();i++)
		{
			if (isprint(input[i]))
				output += input[i];
			else
			{
				char hexcode[10];
				sprintf(hexcode, "0x%X", input[i]);
				output += hexcode;
			}
		}
		return output;
	}

	std::string decode(unsigned char data[], unsigned len)
	{
		std::string out = "";

		std::string entry;
		char ch;
		unsigned int prevcode, currcode;

		prevcode = this->getValue(data);
	
		try{
			out += this->getToken(prevcode);
		}
		catch (int error)
		{
			printf("Error with gettoken at start\n");
			return out;
		}
		unsigned count = 0;


		while (this->position < len*8)
		{
			unsigned int badVal = -1;
			currcode = this->getValue(data);

			if (currcode == 0x100)
				break;

			try{
				entry = getToken(currcode);
			}
			catch (int error)
			{
				//printf("Error with gettoken at second time\n");
				//return out;
				badVal = currcode;
				currcode = prevcode;
				entry = getToken(currcode);
			}

			if (entry[0] == NULL)
			{
				printf("Currcode is invalid: %x ",currcode);
				return "INV";
			}
			out += entry;

			ch = entry[0];
			//add((translation of prevcode) + ch) to dictionary;

			//printf("Currcode: %x\n", currcode);

			try{
				this->addToken(this->getToken(prevcode) + ch);
			} 
			catch(int a) {
				printf("Fuck %x (Curr %x)\n",prevcode,currcode);
			}
			prevcode = currcode;
			if (badVal != -1)
				prevcode = badVal;
		}
		return out;
	}
	/*std::string	decode(unsigned char data[], unsigned length)
	{
		printf("Decode: %u (%x)\n",length,length);
		std::string	out;
		std::string token;
		out.clear();

		std::string	translated;

		unsigned count = length * 8 / 9;

		for (unsigned i = 0; i < count; i++)
		{
			unsigned short value = this->getValue(data, i);

			translated.clear();

			if (value < 256)
			{
				translated.push_back((char) value);
			}
			else {
				if (!this->getTokenForID(value, &translated))
				{
					printf("Error. Failed to tranlate input into output.\n");
				}
				printf("'%s' (%u)\n",translated.c_str(),translated.size());

			}
			//printf(">%x\t'%s' \n",value,translated.c_str());
			out += translated;
			std::string previous = token;
			token += translated;
			//token += translated[0];

			if (!this->isTokenInDict(token))
			{
				this->addToken(token);
				printf("Tok for code: %4x: %4x (%4s) - previous tok: %4s \n",value,this->dict[token],toHex(token).c_str(),toHex(previous).c_str());
				token = translated;
			}

		}
		//printf("%s\n",out.c_str());

		printf("Bits read: %u (%u bytes)\n", length*9, length*9/ 8);
		return out;
	}*/

};



//unsigned char data[] = { 0x70, 0xF0, 0xA5, 0x01, 0x21, 0xE6, 0x8D, 0x9A, 0x81, 0x75, 0xD6, 0xBC, 0x11, 0x38, 0x87, 0x4E, 0xBB, 0x36, 0x65, 0x5C, 0x80, 0x98, 0xF2, 0xA6, 0x0E, 0x19, 0x39, 0x75, 0xF4, 0xA4, 0x61, 0x01, 0xA2, 0x4D, 0x9D, 0x39, 0x0F, 0xCB, 0x80, 0xD0, 0x63, 0xA7, 0x1D, 0x1D, 0x76, 0x1A, 0xE9, 0x84, 0x00, 0xA1, 0x25, 0xCC, 0x44, 0x3A, 0x72, 0xC2, 0xB8, 0xA9, 0xB3, 0xB2, 0x25, 0x08, 0x26, 0x69, 0xC8, 0xD4, 0x74, 0x69, 0x25, 0x4D, 0x19, 0x3A, 0x4E, 0xC2, 0xB4, 0x09, 0xD1, 0x40, 0xC1, 0x88, 0x18, 0x31, 0x6A, 0xC8, 0xD0, 0x01, 0x22, 0xC1, 0x88, 0x31, 0x7A, 0x44, 0x2E, 0xA9, 0xC3, 0xE6, 0x0D, 0x44, 0x3A, 0xE8, 0xDA, 0xAD, 0x29, 0x7A, 0x34, 0xE9, 0x0C, 0xA6, 0x4E, 0xA1, 0x8A, 0xA4, 0x52, 0xC6, 0x0D, 0x9D, 0x37, 0x20, 0xE6, 0x54, 0xBC, 0x58, 0x07, 0x0D, 0x08, 0x35, 0x22, 0xED, 0x94, 0x61, 0xD3, 0x66, 0xA0, 0x5C, 0xBA, 0x03, 0xE7, 0xA4, 0x61, 0xE3, 0xA6, 0x9F, 0xC4, 0x26, 0x1F, 0xDB, 0x11, 0xEC, 0x47, 0x87, 0xA3, 0x9B, 0x32, 0x05, 0x3B, 0xBD, 0x15, 0x09, 0x17, 0x0D, 0x5A, 0x7D, 0x0A, 0xD9, 0x94, 0x69, 0x03, 0xC2, 0x4D, 0xBA, 0x86, 0x20, 0x5C, 0xDA, 0xB9, 0x4C, 0x07, 0x04, 0x9C, 0x30, 0x6C, 0xC4, 0xD4, 0xA9, 0xEC, 0x32, 0x4D, 0x1B, 0x38, 0x65, 0xE4, 0xA4, 0x01, 0x9D, 0xA6, 0x61, 0x9A, 0x31, 0x6B, 0xD2, 0x39, 0xAE, 0x5C, 0x26, 0xA0, 0xC9, 0xB9, 0x22, 0xE1, 0x58, 0x7D, 0x33, 0x46, 0xB0, 0x08, 0x29, 0x75, 0xD0, 0xB9, 0x79, 0x73, 0x06, 0x2D, 0x14 };

unsigned	char data[] = { 0x4C, 0xD2,
0xCC, 0xA1, 0x03, 0xE2, 0x8D, 0x19, 0x10, 0x64, 0xDE, 0x8C, 0xA9, 0xD3, 0xA6, 0x8C, 0x1B, 0x3A, 0x73, 0x1A, 0x28,
0x78, 0xF1, 0x22, 0x88, 0x9C, 0x32, 0x61, 0x40, 0xA0, 0x09, 0xE3, 0x86, 0x8C, 0x98, 0x37, 0x6F, 0xD6, 0x80, 0x30,
0xF3, 0x46, 0x0E, 0x88, 0x29, 0x6F, 0xEA, 0xD0, 0x41, 0x03, 0xC2, 0x4A, 0x9A, 0x32, 0x74, 0xDC, 0x84, 0x69, 0x23,
0x91, 0xE2, 0x12, 0x37, 0x6F, 0xEE, 0x80, 0xC8, 0x93, 0xD2, 0xA4, 0xC3, 0x32, 0x6D, 0xF2, 0xE8, 0x68, 0xF9, 0x92,
0xCE, 0x98, 0x37, 0x6E, 0xCE, 0xD4, 0x7C, 0x71, 0x33, 0xE7, 0xCE, 0x9E, 0x20, 0x7E, 0x06, 0x1D, 0xEA, 0xA4, 0xE4,
0x4A, 0xA2, 0x30, 0x65, 0x36, 0x9C, 0x53, 0x06, 0x84, 0xC5, 0xA0, 0x4B, 0x5D, 0x66, 0x9D, 0x59, 0x86, 0x2B, 0x08,
0x38, 0x68, 0xE4, 0x84, 0xE1, 0x1A, 0x71, 0xE2, 0x0B, 0x2A, 0x68, 0xBA, 0x36, 0x41, 0x4A, 0x27, 0xCC, 0x19, 0x99,
0x72, 0xC8, 0xB4, 0xB5, 0x89, 0x53, 0x27, 0xCF, 0x3A, 0x26, 0xC3, 0xB0, 0x61, 0x23, 0xD4, 0xAB, 0x9C, 0xA0, 0x05,
0x0F, 0x4A, 0x29, 0x03, 0xA7, 0x8E, 0x18, 0x36, 0x69, 0xC6, 0x24, 0xC6, 0x1A, 0x73, 0x66, 0xD8, 0xA2, 0x5A, 0x41,
0xD4, 0xE9, 0x58, 0xC6, 0xA4, 0x91, 0x8B, 0x6E, 0xC6, 0xB0, 0x94, 0x53, 0x87, 0x4D, 0x99, 0xA5, 0x48, 0x04, 0xD2,
0x29, 0x19, 0x59, 0x30, 0x08, 0xAE, 0x74, 0xE8, 0xA4, 0x49, 0x3A, 0x67, 0xA8, 0xD8, 0xCA, 0x6D, 0xCE, 0xE2, 0x2B,
0x43, 0x46, 0x77, 0x3B, 0xD1, 0x6F, 0xC8, 0x00, 0x8D, 0x6A, 0x47, 0xCE, 0x1B, 0x38, 0x1C, 0xF3, 0x2D, 0x15, 0xF2,
0xE4, 0x89, 0x90, 0x2C, 0x20, 0xA8, 0x48, 0x09, 0x02, 0x65, 0xCA, 0x52, 0x2A, 0x55, 0x9C, 0x38, 0x29, 0xC2, 0xC4,
0xBA, 0xDB, 0x21, 0x41, 0x86, 0x20, 0x29, 0xE2, 0x9D, 0x62, 0xF5, 0x2C, 0x57, 0x82, 0x48, 0x59, 0x7A, 0xA4, 0x4A,
0x12, 0x22, 0xDC, 0x93, 0x6C, 0x9F, 0x02, 0xC2, 0xC8, 0x13, 0x29, 0x5E, 0x89, 0x58, 0x49, 0x32, 0xE5, 0x7E, 0xF9,
0x17, 0xE4, 0x33, 0x22, 0x09, 0x26, 0xA4, 0x0B, 0x82, 0x8A, 0x24, 0x9E, 0x70, 0x02, 0x84, 0x27, 0x8C, 0x00, 0x61,
0x88, 0x27, 0x9A, 0x68, 0x22, 0x3B, 0xFE, 0xA8, 0xA8, 0xEF, 0xBE, 0x21, 0xC8, 0x5B, 0xEA, 0x8A, 0xFB, 0x96, 0x90,
0xEF, 0x08, 0x10, 0xAE, 0x48, 0x82, 0x0A, 0x24, 0xA2, 0x1B, 0x0F, 0x04, 0x21, 0x82, 0x40, 0xC2, 0x09, 0xF5, 0x96,
0x7A, 0x10, 0xBE, 0x05, 0x1B, 0x7C, 0xD0, 0x09, 0x22, 0xAA, 0x18, 0x82, 0x8A, 0xA5, 0x8A, 0xD8, 0xAE, 0x09, 0xE8,
0xE4, 0x03, 0x21, 0x8B, 0x27, 0xAA, 0xC0, 0x0F, 0x89, 0x20, 0x66, 0xFC, 0x6F, 0x8A, 0x06, 0xA1, 0x98, 0x2E, 0x8B,
0x22, 0xD6, 0x73, 0xEB, 0x48, 0x07, 0xA5, 0x28, 0xA2, 0x08, 0x22, 0x96, 0x6A, 0x22, 0x06, 0x1B, 0x40, 0x90, 0x22,
0x09, 0x23, 0x98, 0x28, 0x22, 0xBA, 0x24, 0xAA, 0x93, 0x48, 0x4C, 0xB7, 0x54, 0x28, 0xD3, 0xCC, 0x33, 0xD1, 0x4C,
0x53, 0xCD, 0x35, 0xD9, 0x6C, 0xD3, 0xCD, 0x37, 0xE1, 0x8C, 0x73, 0xA9, 0x38, 0xE9, 0xAC, 0xD3, 0xCE, 0x3B, 0xF1,
0x4C, 0x73, 0xCE, 0x3C, 0xF9, 0xEC, 0xD3, 0xCF, 0x3B, 0x97, 0x0A, 0x42, 0xC0, 0x22, 0xF6, 0xFC, 0xD3, 0xD0, 0x43,
0x11, 0x55, 0xA1, 0xD0, 0x44, 0x19, 0x6D, 0x94, 0xCE, 0x45, 0x1D, 0x8D, 0x54, 0x52, 0x34, 0xC7, 0xA4, 0x68, 0xD2,
0x4B, 0x1F, 0x75, 0xCB, 0x09, 0xB2, 0x46, 0x2A, 0x09, 0x84, 0x95, 0xBA, 0x12, 0xC3, 0x38, 0xD1, 0x00, 0xEB, 0x0A,
0xB2, 0x81, 0x24, 0x1A, 0xE1, 0x86, 0x1C, 0x60, 0xC0, 0x41, 0x87, 0x54, 0xC7, 0xD0, 0xA3, 0x2B, 0x89, 0x94, 0x48,
0xC2, 0x11, 0x27, 0x9A, 0x69, 0x29, 0x89, 0x22, 0xA8, 0x58, 0xB1, 0x09, 0x48, 0x31, 0x0D, 0x56, 0x4F, 0x05, 0x96,
0x82, 0x22, 0x32, 0x3A, 0x4A, 0x3D, 0x29, 0xA5, 0xAB, 0x6E, 0xD3, 0x0A, 0x86, 0x18, 0x2A, 0xAD, 0x68, 0xD0, 0xE8,
0xD2, 0xA0, 0xC3, 0x34, 0x10, 0x2C, 0xE9, 0xD4, 0x24, 0x50, 0x47, 0x4A, 0x43, 0x8E, 0x81, 0xCE, 0xB2, 0xEB, 0x34,
0x05, 0x54, 0x65, 0x35, 0x87, 0x57, 0xC9, 0x8D, 0x75, 0x5C, 0x28, 0xE4, 0xC8, 0xC7, 0x8E, 0xE0, 0xC6, 0xE8, 0xEA,
0x8D, 0xC7, 0xD6, 0xA2, 0xA3, 0x1D, 0x10, 0x94, 0x48, 0xC3, 0x13, 0x37, 0xDA, 0x41, 0xE3, 0x0D, 0xCA, 0xB4, 0xAA,
0x63, 0xCC, 0x72, 0x63, 0x80, 0x01, 0xDD, 0x11, 0xD4, 0x95, 0x68, 0xB1, 0xC6, 0x1E, 0x4B, 0x63, 0x8D, 0x8C, 0x9A,
0x9D, 0xA9, 0x20, 0x31, 0xEC, 0xC8, 0x63, 0x8D, 0x6B, 0xDF, 0xD0, 0x43, 0x26, 0x74, 0xDE, 0xB0, 0x83, 0xA3, 0x70,
0x40, 0x50, 0x23, 0x8C, 0x35, 0xFE, 0xCD, 0x77, 0xDF, 0x7B, 0x23, 0x6E, 0x83, 0x85, 0xD7, 0xBA, 0x32, 0x4E, 0x8F,
0x8B, 0xC3, 0x21, 0x03, 0x64, 0x50, 0x64, 0x02, 0x41, 0xB7, 0x34, 0x1A, 0xDE, 0x97, 0x1D, 0x10, 0x6C, 0xB0, 0x81,
0x05, 0x19, 0x60, 0x80, 0x01, 0x04, 0x74, 0xE8, 0xB0, 0xA3, 0xB3, 0x32, 0xD0, 0xE1, 0x57, 0x34, 0x10, 0xDA, 0x68,
0x87, 0x8D, 0xDF, 0x58, 0xAA, 0xD9, 0x8E, 0x7E, 0x80, 0x23, 0x83, 0xDF, 0xA1, 0xC3, 0x19, 0x28, 0x0D, 0x7C, 0xD3,
0xF0, 0x77, 0xEA, 0xAA, 0xF9, 0xF5, 0xD7, 0xAB, 0x39, 0xD2, 0x50, 0x63, 0x8E, 0x35, 0xD2, 0x11, 0x1B, 0x8E, 0x37,
0xD8, 0x00, 0x69, 0x20, 0xE3, 0x3C, 0x5E, 0x79, 0x0D, 0x3A, 0x3A, 0xEB, 0x87, 0x65, 0x10, 0x64, 0x12, 0x2D, 0x1C
};

void printIt(unsigned char* data, unsigned size)
{
	uint32_t chr;
	uint32_t bitsRead = 0;

	while (bitsRead < size << 3)
	{
		chr = *(uint32_t*)(data + (bitsRead / 8));
		//printf("Hex: %X\n",chr);
		chr >>= (bitsRead % 8);
		chr = chr & ~(~0 << 9);
		//if(chr < 127)
		//      printf("%c",chr,chr);

		if (chr > 255)
			printf("Alert. Dictionary overreached...\n");
		bitsRead += 9;
	}

	printf("Bits read: %u (%u bytes)\n",bitsRead,bitsRead/8);
	printf("\n");
}

typedef struct {
	uint32_t	magic;
	uint32_t	input;
	uint32_t	ouput;
} fileHead;


unsigned char buff[0x2100000];

int main(int argc, char * argv[])
{
	//printIt(data, atoi(argv[1]));


	std::setlocale(LC_ALL, "en_US.UTF-8");

	int length = sizeof(data);

	if (argc > 1)
		length = atoi(argv[1]);

	FILE* input = fopen("vietcong_spdcz.cbf", "rb");
	if (!input)
	{
		printf("Failed to open file\n");
		return 1;
	}

	int pos = fseek(input, 0x030B104C, SEEK_SET);

	fileHead	head;
	fread(&head, sizeof(fileHead), 1, input);

	printf("Pos: %u\n",pos);


	unsigned int result = 0;
	if ((result = fread(buff, 1, head.input, input)) == 0)
	{
		printf("Fail\n");
		return 1;
	}

	printf("Read: %x\n",result);


	Decoder dec;
	//std::string output = dec.decode(data,sizeof(data));
	std::string output = dec.decode(buff, head.input);


	printf("Input length: %u - output %u\n",length,output.size());

	//system("pause");

	//for (auto m: dec.)


	printf("%s\n",output.c_str());
	FILE* out = fopen("output.bin","wb");
	if (out)
	{
		fwrite(output.c_str(), output.size(), 1, out);
		fclose(out);
	}
	return 0;
}
